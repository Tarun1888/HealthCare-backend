{"ast":null,"code":"const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcryptjs');\nconst path = require('path');\nconst app = express();\nconst PORT = process.env.PORT || 5000;\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';\n\n// Middleware\napp.use(cors());\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({\n  extended: true\n}));\n\n// SQLite DB\nconst db = new sqlite3.Database('./data.db', err => {\n  if (err) {\n    console.error('Failed to connect to DB:', err.message);\n  } else {\n    console.log('Connected to SQLite DB.');\n    db.serialize(() => {\n      // Users table\n      db.run(`CREATE TABLE IF NOT EXISTS users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL,\n        email TEXT UNIQUE NOT NULL,\n        password TEXT NOT NULL,\n        role TEXT DEFAULT 'patient',\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )`);\n\n      // Doctors table\n      db.run(`CREATE TABLE IF NOT EXISTS doctors (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL,\n        specialization TEXT NOT NULL,\n        profile_image TEXT,\n        availability_status TEXT DEFAULT 'available',\n        email TEXT,\n        phone TEXT,\n        experience_years INTEGER,\n        rating REAL DEFAULT 4.5,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )`);\n\n      // Appointments table\n      db.run(`CREATE TABLE IF NOT EXISTS appointments (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        user_id INTEGER,\n        doctor_id INTEGER,\n        patient_name TEXT NOT NULL,\n        patient_email TEXT NOT NULL,\n        appointment_date TEXT NOT NULL,\n        appointment_time TEXT NOT NULL,\n        status TEXT DEFAULT 'scheduled',\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (user_id) REFERENCES users (id),\n        FOREIGN KEY (doctor_id) REFERENCES doctors (id)\n      )`);\n\n      // Insert sample doctors if none exist\n      db.get(\"SELECT COUNT(*) AS count FROM doctors\", (err, row) => {\n        if (row.count === 0) {\n          const sampleDoctors = [['Dr. Sarah Johnson', 'Cardiologist', 'https://images.unsplash.com/photo-1559839734-2b71ea197ec2?w=300', 'sarah@hospital.com', '555-0101', 12, 4.8], ['Dr. Michael Chen', 'Dermatologist', 'https://images.unsplash.com/photo-1612349317150-e413f6a5b16d?w=300', 'michael@hospital.com', '555-0102', 8, 4.6], ['Dr. Emily Rodriguez', 'Pediatrician', 'https://images.unsplash.com/photo-1594824475338-bb16d0797516?w=300', 'emily@hospital.com', '555-0103', 15, 4.9], ['Dr. James Wilson', 'Orthopedic', 'https://images.unsplash.com/photo-1582750433449-648ed127bb54?w=300', 'james@hospital.com', '555-0104', 20, 4.7], ['Dr. Lisa Thompson', 'Neurologist', 'https://images.unsplash.com/photo-1559757175-0eb30cd8c063?w=300', 'lisa@hospital.com', '555-0105', 10, 4.5]];\n          const stmt = db.prepare(\"INSERT INTO doctors (name, specialization, profile_image, email, phone, experience_years, rating) VALUES (?, ?, ?, ?, ?, ?, ?)\");\n          sampleDoctors.forEach(doc => stmt.run(doc));\n          stmt.finalize();\n          console.log('Sample doctors inserted');\n        }\n      });\n    });\n  }\n});\n\n// JWT Middleware\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (!token) {\n    return res.status(401).json({\n      error: 'Access token required'\n    });\n  }\n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({\n        error: 'Invalid or expired token'\n      });\n    }\n    req.user = user;\n    next();\n  });\n};\n\n// Optional authentication middleware (doesn't require token but adds user if present)\nconst optionalAuth = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  if (token) {\n    jwt.verify(token, JWT_SECRET, (err, user) => {\n      if (!err) {\n        req.user = user;\n      }\n    });\n  }\n  next();\n};\n\n// ------------------------ API Routes ------------------------ //\n\n// Health check\napp.get('/api/health', (req, res) => {\n  res.json({\n    message: 'Server is healthy ✅'\n  });\n});\n\n// Signup\napp.post('/api/signup', async (req, res) => {\n  const {\n    name,\n    email,\n    password\n  } = req.body;\n  if (!name || !email || !password) {\n    return res.status(400).json({\n      error: 'All fields are required'\n    });\n  }\n  if (password.length < 6) {\n    return res.status(400).json({\n      error: 'Password must be at least 6 characters'\n    });\n  }\n  try {\n    // Hash password\n    const saltRounds = 10;\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\n    const stmt = db.prepare('INSERT INTO users (name, email, password) VALUES (?, ?, ?)');\n    stmt.run(name, email, hashedPassword, function (err) {\n      if (err) {\n        if (err.message.includes('UNIQUE')) {\n          return res.status(409).json({\n            error: 'Email already registered'\n          });\n        }\n        return res.status(500).json({\n          error: 'Database error'\n        });\n      }\n\n      // Generate JWT token\n      const token = jwt.sign({\n        userId: this.lastID,\n        email: email,\n        name: name,\n        role: 'patient'\n      }, JWT_SECRET, {\n        expiresIn: '24h'\n      });\n      res.status(201).json({\n        message: 'Signup successful',\n        token: token,\n        user: {\n          id: this.lastID,\n          name: name,\n          email: email,\n          role: 'patient'\n        }\n      });\n    });\n  } catch (error) {\n    res.status(500).json({\n      error: 'Server error during signup'\n    });\n  }\n});\n\n// Login\napp.post('/api/login', async (req, res) => {\n  const {\n    email,\n    password\n  } = req.body;\n  if (!email || !password) {\n    return res.status(400).json({\n      error: 'Email and password required'\n    });\n  }\n  db.get('SELECT * FROM users WHERE email = ?', [email], async (err, user) => {\n    if (err) {\n      return res.status(500).json({\n        error: 'Database error'\n      });\n    }\n    if (!user) {\n      return res.status(401).json({\n        error: 'Invalid credentials'\n      });\n    }\n    try {\n      // Compare password\n      const isValidPassword = await bcrypt.compare(password, user.password);\n      if (!isValidPassword) {\n        return res.status(401).json({\n          error: 'Invalid credentials'\n        });\n      }\n\n      // Generate JWT token\n      const token = jwt.sign({\n        userId: user.id,\n        email: user.email,\n        name: user.name,\n        role: user.role || 'patient'\n      }, JWT_SECRET, {\n        expiresIn: '24h'\n      });\n      res.json({\n        message: 'Login successful',\n        token: token,\n        user: {\n          id: user.id,\n          name: user.name,\n          email: user.email,\n          role: user.role || 'patient'\n        }\n      });\n    } catch (error) {\n      res.status(500).json({\n        error: 'Server error during login'\n      });\n    }\n  });\n});\n\n// Verify token endpoint\napp.get('/api/verify-token', authenticateToken, (req, res) => {\n  res.json({\n    message: 'Token is valid',\n    user: {\n      id: req.user.userId,\n      name: req.user.name,\n      email: req.user.email,\n      role: req.user.role\n    }\n  });\n});\n\n// Get all doctors (public access, but enhanced with user info if logged in)\napp.get('/api/doctors', optionalAuth, (req, res) => {\n  const {\n    search\n  } = req.query;\n  let sql = \"SELECT * FROM doctors\";\n  let params = [];\n  if (search) {\n    sql += \" WHERE name LIKE ? OR specialization LIKE ?\";\n    params = [`%${search}%`, `%${search}%`];\n  }\n  db.all(sql, params, (err, rows) => {\n    if (err) return res.status(500).json({\n      error: err.message\n    });\n\n    // Add user context if authenticated\n    const response = {\n      data: rows,\n      user: req.user ? {\n        id: req.user.userId,\n        name: req.user.name,\n        email: req.user.email\n      } : null\n    };\n    res.json(response);\n  });\n});\n\n// Get doctor by ID (public access)\napp.get('/api/doctors/:id', optionalAuth, (req, res) => {\n  db.get(\"SELECT * FROM doctors WHERE id = ?\", [req.params.id], (err, row) => {\n    if (err) return res.status(500).json({\n      error: err.message\n    });\n    if (!row) return res.status(404).json({\n      error: 'Doctor not found'\n    });\n    const response = {\n      data: row,\n      user: req.user ? {\n        id: req.user.userId,\n        name: req.user.name,\n        email: req.user.email\n      } : null\n    };\n    res.json(response);\n  });\n});\n\n// Book appointment (requires authentication)\napp.post('/api/appointments', authenticateToken, (req, res) => {\n  const {\n    doctor_id,\n    patient_name,\n    patient_email,\n    appointment_date,\n    appointment_time\n  } = req.body;\n  const user_id = req.user.userId;\n  if (!doctor_id || !patient_name || !patient_email || !appointment_date || !appointment_time) {\n    return res.status(400).json({\n      error: \"All fields are required\"\n    });\n  }\n\n  // Verify doctor exists\n  db.get(\"SELECT * FROM doctors WHERE id = ?\", [doctor_id], (err, doctor) => {\n    if (err) return res.status(500).json({\n      error: err.message\n    });\n    if (!doctor) return res.status(404).json({\n      error: 'Doctor not found'\n    });\n\n    // Check for existing appointment\n    db.get(\"SELECT * FROM appointments WHERE doctor_id = ? AND appointment_date = ? AND appointment_time = ? AND status != 'cancelled'\", [doctor_id, appointment_date, appointment_time], (err, existing) => {\n      if (err) return res.status(500).json({\n        error: err.message\n      });\n      if (existing) return res.status(409).json({\n        error: \"Slot already booked\"\n      });\n\n      // Create appointment\n      db.run(\"INSERT INTO appointments (user_id, doctor_id, patient_name, patient_email, appointment_date, appointment_time) VALUES (?, ?, ?, ?, ?, ?)\", [user_id, doctor_id, patient_name, patient_email, appointment_date, appointment_time], function (err) {\n        if (err) return res.status(500).json({\n          error: err.message\n        });\n        res.status(201).json({\n          message: \"Appointment booked successfully\",\n          data: {\n            id: this.lastID,\n            user_id,\n            doctor_id,\n            patient_name,\n            patient_email,\n            appointment_date,\n            appointment_time,\n            doctor_name: doctor.name,\n            doctor_specialization: doctor.specialization\n          }\n        });\n      });\n    });\n  });\n});\n\n// Get user's appointments (requires authentication)\napp.get('/api/my-appointments', authenticateToken, (req, res) => {\n  const user_id = req.user.userId;\n  const sql = `\n    SELECT a.*, d.name as doctor_name, d.specialization, d.profile_image \n    FROM appointments a \n    JOIN doctors d ON a.doctor_id = d.id \n    WHERE a.user_id = ? \n    ORDER BY a.appointment_date DESC, a.appointment_time DESC\n  `;\n  db.all(sql, [user_id], (err, rows) => {\n    if (err) return res.status(500).json({\n      error: err.message\n    });\n    res.json({\n      data: rows\n    });\n  });\n});\n\n// Get appointments by doctor ID (public, for checking availability)\napp.get('/api/doctors/:id/appointments', optionalAuth, (req, res) => {\n  const {\n    date\n  } = req.query;\n  const params = [req.params.id];\n  let sql = \"SELECT appointment_date, appointment_time FROM appointments WHERE doctor_id = ? AND status != 'cancelled'\";\n  if (date) {\n    sql += \" AND appointment_date = ?\";\n    params.push(date);\n  }\n  db.all(sql, params, (err, rows) => {\n    if (err) return res.status(500).json({\n      error: err.message\n    });\n    // Only return time slots, not personal info\n    const bookedSlots = rows.map(row => ({\n      date: row.appointment_date,\n      time: row.appointment_time\n    }));\n    res.json({\n      data: bookedSlots\n    });\n  });\n});\n\n// Cancel appointment (requires authentication)\napp.patch('/api/appointments/:id/cancel', authenticateToken, (req, res) => {\n  const appointmentId = req.params.id;\n  const userId = req.user.userId;\n\n  // Verify appointment belongs to user\n  db.get(\"SELECT * FROM appointments WHERE id = ? AND user_id = ?\", [appointmentId, userId], (err, appointment) => {\n    if (err) return res.status(500).json({\n      error: err.message\n    });\n    if (!appointment) return res.status(404).json({\n      error: 'Appointment not found or unauthorized'\n    });\n\n    // Update appointment status\n    db.run(\"UPDATE appointments SET status = 'cancelled' WHERE id = ?\", [appointmentId], function (err) {\n      if (err) return res.status(500).json({\n        error: err.message\n      });\n      res.json({\n        message: 'Appointment cancelled successfully'\n      });\n    });\n  });\n});\n\n// Logout (client-side token removal, but useful for logging)\napp.post('/api/logout', authenticateToken, (req, res) => {\n  // In a production app, you might want to blacklist the token\n  res.json({\n    message: 'Logout successful'\n  });\n});\n\n// ------------------------ Start Server ------------------------ //\n\napp.listen(PORT, () => {\n  console.log(`✅ Server running at http://localhost:${PORT}`);\n  console.log(`🔐 JWT Authentication enabled`);\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n  db.close(() => {\n    console.log('\\nDatabase closed. Server shutting down.');\n    process.exit(0);\n  });\n});","map":{"version":3,"names":["express","require","sqlite3","verbose","cors","bodyParser","jwt","bcrypt","path","app","PORT","process","env","JWT_SECRET","use","json","urlencoded","extended","db","Database","err","console","error","message","log","serialize","run","get","row","count","sampleDoctors","stmt","prepare","forEach","doc","finalize","authenticateToken","req","res","next","authHeader","headers","token","split","status","verify","user","optionalAuth","post","name","email","password","body","length","saltRounds","hashedPassword","hash","includes","sign","userId","lastID","role","expiresIn","id","isValidPassword","compare","search","query","sql","params","all","rows","response","data","doctor_id","patient_name","patient_email","appointment_date","appointment_time","user_id","doctor","existing","doctor_name","doctor_specialization","specialization","date","push","bookedSlots","map","time","patch","appointmentId","appointment","listen","on","close","exit"],"sources":["C:/Users/Tarun/OneDrive/Desktop/NirogGyan/healthcare-booking-app/src/components/SearchBar.js"],"sourcesContent":["const express = require('express');\r\nconst sqlite3 = require('sqlite3').verbose();\r\nconst cors = require('cors');\r\nconst bodyParser = require('body-parser');\r\nconst jwt = require('jsonwebtoken');\r\nconst bcrypt = require('bcryptjs');\r\nconst path = require('path');\r\n\r\nconst app = express();\r\nconst PORT = process.env.PORT || 5000;\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';\r\n\r\n// Middleware\r\napp.use(cors());\r\napp.use(bodyParser.json());\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n// SQLite DB\r\nconst db = new sqlite3.Database('./data.db', (err) => {\r\n  if (err) {\r\n    console.error('Failed to connect to DB:', err.message);\r\n  } else {\r\n    console.log('Connected to SQLite DB.');\r\n\r\n    db.serialize(() => {\r\n      // Users table\r\n      db.run(`CREATE TABLE IF NOT EXISTS users (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        name TEXT NOT NULL,\r\n        email TEXT UNIQUE NOT NULL,\r\n        password TEXT NOT NULL,\r\n        role TEXT DEFAULT 'patient',\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n      )`);\r\n\r\n      // Doctors table\r\n      db.run(`CREATE TABLE IF NOT EXISTS doctors (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        name TEXT NOT NULL,\r\n        specialization TEXT NOT NULL,\r\n        profile_image TEXT,\r\n        availability_status TEXT DEFAULT 'available',\r\n        email TEXT,\r\n        phone TEXT,\r\n        experience_years INTEGER,\r\n        rating REAL DEFAULT 4.5,\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n      )`);\r\n\r\n      // Appointments table\r\n      db.run(`CREATE TABLE IF NOT EXISTS appointments (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        user_id INTEGER,\r\n        doctor_id INTEGER,\r\n        patient_name TEXT NOT NULL,\r\n        patient_email TEXT NOT NULL,\r\n        appointment_date TEXT NOT NULL,\r\n        appointment_time TEXT NOT NULL,\r\n        status TEXT DEFAULT 'scheduled',\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        FOREIGN KEY (user_id) REFERENCES users (id),\r\n        FOREIGN KEY (doctor_id) REFERENCES doctors (id)\r\n      )`);\r\n\r\n      // Insert sample doctors if none exist\r\n      db.get(\"SELECT COUNT(*) AS count FROM doctors\", (err, row) => {\r\n        if (row.count === 0) {\r\n          const sampleDoctors = [\r\n            ['Dr. Sarah Johnson', 'Cardiologist', 'https://images.unsplash.com/photo-1559839734-2b71ea197ec2?w=300', 'sarah@hospital.com', '555-0101', 12, 4.8],\r\n            ['Dr. Michael Chen', 'Dermatologist', 'https://images.unsplash.com/photo-1612349317150-e413f6a5b16d?w=300', 'michael@hospital.com', '555-0102', 8, 4.6],\r\n            ['Dr. Emily Rodriguez', 'Pediatrician', 'https://images.unsplash.com/photo-1594824475338-bb16d0797516?w=300', 'emily@hospital.com', '555-0103', 15, 4.9],\r\n            ['Dr. James Wilson', 'Orthopedic', 'https://images.unsplash.com/photo-1582750433449-648ed127bb54?w=300', 'james@hospital.com', '555-0104', 20, 4.7],\r\n            ['Dr. Lisa Thompson', 'Neurologist', 'https://images.unsplash.com/photo-1559757175-0eb30cd8c063?w=300', 'lisa@hospital.com', '555-0105', 10, 4.5],\r\n          ];\r\n\r\n          const stmt = db.prepare(\"INSERT INTO doctors (name, specialization, profile_image, email, phone, experience_years, rating) VALUES (?, ?, ?, ?, ?, ?, ?)\");\r\n          sampleDoctors.forEach(doc => stmt.run(doc));\r\n          stmt.finalize();\r\n          console.log('Sample doctors inserted');\r\n        }\r\n      });\r\n    });\r\n  }\r\n});\r\n\r\n// JWT Middleware\r\nconst authenticateToken = (req, res, next) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\r\n\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'Access token required' });\r\n  }\r\n\r\n  jwt.verify(token, JWT_SECRET, (err, user) => {\r\n    if (err) {\r\n      return res.status(403).json({ error: 'Invalid or expired token' });\r\n    }\r\n    req.user = user;\r\n    next();\r\n  });\r\n};\r\n\r\n// Optional authentication middleware (doesn't require token but adds user if present)\r\nconst optionalAuth = (req, res, next) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n\r\n  if (token) {\r\n    jwt.verify(token, JWT_SECRET, (err, user) => {\r\n      if (!err) {\r\n        req.user = user;\r\n      }\r\n    });\r\n  }\r\n  next();\r\n};\r\n\r\n// ------------------------ API Routes ------------------------ //\r\n\r\n// Health check\r\napp.get('/api/health', (req, res) => {\r\n  res.json({ message: 'Server is healthy ✅' });\r\n});\r\n\r\n// Signup\r\napp.post('/api/signup', async (req, res) => {\r\n  const { name, email, password } = req.body;\r\n  \r\n  if (!name || !email || !password) {\r\n    return res.status(400).json({ error: 'All fields are required' });\r\n  }\r\n\r\n  if (password.length < 6) {\r\n    return res.status(400).json({ error: 'Password must be at least 6 characters' });\r\n  }\r\n\r\n  try {\r\n    // Hash password\r\n    const saltRounds = 10;\r\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\r\n\r\n    const stmt = db.prepare('INSERT INTO users (name, email, password) VALUES (?, ?, ?)');\r\n    stmt.run(name, email, hashedPassword, function (err) {\r\n      if (err) {\r\n        if (err.message.includes('UNIQUE')) {\r\n          return res.status(409).json({ error: 'Email already registered' });\r\n        }\r\n        return res.status(500).json({ error: 'Database error' });\r\n      }\r\n\r\n      // Generate JWT token\r\n      const token = jwt.sign(\r\n        { \r\n          userId: this.lastID, \r\n          email: email,\r\n          name: name,\r\n          role: 'patient'\r\n        },\r\n        JWT_SECRET,\r\n        { expiresIn: '24h' }\r\n      );\r\n\r\n      res.status(201).json({\r\n        message: 'Signup successful',\r\n        token: token,\r\n        user: {\r\n          id: this.lastID,\r\n          name: name,\r\n          email: email,\r\n          role: 'patient'\r\n        }\r\n      });\r\n    });\r\n  } catch (error) {\r\n    res.status(500).json({ error: 'Server error during signup' });\r\n  }\r\n});\r\n\r\n// Login\r\napp.post('/api/login', async (req, res) => {\r\n  const { email, password } = req.body;\r\n  \r\n  if (!email || !password) {\r\n    return res.status(400).json({ error: 'Email and password required' });\r\n  }\r\n\r\n  db.get('SELECT * FROM users WHERE email = ?', [email], async (err, user) => {\r\n    if (err) {\r\n      return res.status(500).json({ error: 'Database error' });\r\n    }\r\n\r\n    if (!user) {\r\n      return res.status(401).json({ error: 'Invalid credentials' });\r\n    }\r\n\r\n    try {\r\n      // Compare password\r\n      const isValidPassword = await bcrypt.compare(password, user.password);\r\n      \r\n      if (!isValidPassword) {\r\n        return res.status(401).json({ error: 'Invalid credentials' });\r\n      }\r\n\r\n      // Generate JWT token\r\n      const token = jwt.sign(\r\n        { \r\n          userId: user.id, \r\n          email: user.email,\r\n          name: user.name,\r\n          role: user.role || 'patient'\r\n        },\r\n        JWT_SECRET,\r\n        { expiresIn: '24h' }\r\n      );\r\n\r\n      res.json({\r\n        message: 'Login successful',\r\n        token: token,\r\n        user: {\r\n          id: user.id,\r\n          name: user.name,\r\n          email: user.email,\r\n          role: user.role || 'patient'\r\n        }\r\n      });\r\n    } catch (error) {\r\n      res.status(500).json({ error: 'Server error during login' });\r\n    }\r\n  });\r\n});\r\n\r\n// Verify token endpoint\r\napp.get('/api/verify-token', authenticateToken, (req, res) => {\r\n  res.json({\r\n    message: 'Token is valid',\r\n    user: {\r\n      id: req.user.userId,\r\n      name: req.user.name,\r\n      email: req.user.email,\r\n      role: req.user.role\r\n    }\r\n  });\r\n});\r\n\r\n// Get all doctors (public access, but enhanced with user info if logged in)\r\napp.get('/api/doctors', optionalAuth, (req, res) => {\r\n  const { search } = req.query;\r\n  let sql = \"SELECT * FROM doctors\";\r\n  let params = [];\r\n\r\n  if (search) {\r\n    sql += \" WHERE name LIKE ? OR specialization LIKE ?\";\r\n    params = [`%${search}%`, `%${search}%`];\r\n  }\r\n\r\n  db.all(sql, params, (err, rows) => {\r\n    if (err) return res.status(500).json({ error: err.message });\r\n    \r\n    // Add user context if authenticated\r\n    const response = {\r\n      data: rows,\r\n      user: req.user ? {\r\n        id: req.user.userId,\r\n        name: req.user.name,\r\n        email: req.user.email\r\n      } : null\r\n    };\r\n    \r\n    res.json(response);\r\n  });\r\n});\r\n\r\n// Get doctor by ID (public access)\r\napp.get('/api/doctors/:id', optionalAuth, (req, res) => {\r\n  db.get(\"SELECT * FROM doctors WHERE id = ?\", [req.params.id], (err, row) => {\r\n    if (err) return res.status(500).json({ error: err.message });\r\n    if (!row) return res.status(404).json({ error: 'Doctor not found' });\r\n    \r\n    const response = {\r\n      data: row,\r\n      user: req.user ? {\r\n        id: req.user.userId,\r\n        name: req.user.name,\r\n        email: req.user.email\r\n      } : null\r\n    };\r\n    \r\n    res.json(response);\r\n  });\r\n});\r\n\r\n// Book appointment (requires authentication)\r\napp.post('/api/appointments', authenticateToken, (req, res) => {\r\n  const { doctor_id, patient_name, patient_email, appointment_date, appointment_time } = req.body;\r\n  const user_id = req.user.userId;\r\n\r\n  if (!doctor_id || !patient_name || !patient_email || !appointment_date || !appointment_time) {\r\n    return res.status(400).json({ error: \"All fields are required\" });\r\n  }\r\n\r\n  // Verify doctor exists\r\n  db.get(\"SELECT * FROM doctors WHERE id = ?\", [doctor_id], (err, doctor) => {\r\n    if (err) return res.status(500).json({ error: err.message });\r\n    if (!doctor) return res.status(404).json({ error: 'Doctor not found' });\r\n\r\n    // Check for existing appointment\r\n    db.get(\"SELECT * FROM appointments WHERE doctor_id = ? AND appointment_date = ? AND appointment_time = ? AND status != 'cancelled'\",\r\n      [doctor_id, appointment_date, appointment_time],\r\n      (err, existing) => {\r\n        if (err) return res.status(500).json({ error: err.message });\r\n        if (existing) return res.status(409).json({ error: \"Slot already booked\" });\r\n\r\n        // Create appointment\r\n        db.run(\"INSERT INTO appointments (user_id, doctor_id, patient_name, patient_email, appointment_date, appointment_time) VALUES (?, ?, ?, ?, ?, ?)\",\r\n          [user_id, doctor_id, patient_name, patient_email, appointment_date, appointment_time],\r\n          function (err) {\r\n            if (err) return res.status(500).json({ error: err.message });\r\n            \r\n            res.status(201).json({\r\n              message: \"Appointment booked successfully\",\r\n              data: {\r\n                id: this.lastID,\r\n                user_id,\r\n                doctor_id,\r\n                patient_name,\r\n                patient_email,\r\n                appointment_date,\r\n                appointment_time,\r\n                doctor_name: doctor.name,\r\n                doctor_specialization: doctor.specialization\r\n              }\r\n            });\r\n          });\r\n      });\r\n  });\r\n});\r\n\r\n// Get user's appointments (requires authentication)\r\napp.get('/api/my-appointments', authenticateToken, (req, res) => {\r\n  const user_id = req.user.userId;\r\n  \r\n  const sql = `\r\n    SELECT a.*, d.name as doctor_name, d.specialization, d.profile_image \r\n    FROM appointments a \r\n    JOIN doctors d ON a.doctor_id = d.id \r\n    WHERE a.user_id = ? \r\n    ORDER BY a.appointment_date DESC, a.appointment_time DESC\r\n  `;\r\n\r\n  db.all(sql, [user_id], (err, rows) => {\r\n    if (err) return res.status(500).json({ error: err.message });\r\n    res.json({ data: rows });\r\n  });\r\n});\r\n\r\n// Get appointments by doctor ID (public, for checking availability)\r\napp.get('/api/doctors/:id/appointments', optionalAuth, (req, res) => {\r\n  const { date } = req.query;\r\n  const params = [req.params.id];\r\n  let sql = \"SELECT appointment_date, appointment_time FROM appointments WHERE doctor_id = ? AND status != 'cancelled'\";\r\n\r\n  if (date) {\r\n    sql += \" AND appointment_date = ?\";\r\n    params.push(date);\r\n  }\r\n\r\n  db.all(sql, params, (err, rows) => {\r\n    if (err) return res.status(500).json({ error: err.message });\r\n    // Only return time slots, not personal info\r\n    const bookedSlots = rows.map(row => ({\r\n      date: row.appointment_date,\r\n      time: row.appointment_time\r\n    }));\r\n    res.json({ data: bookedSlots });\r\n  });\r\n});\r\n\r\n// Cancel appointment (requires authentication)\r\napp.patch('/api/appointments/:id/cancel', authenticateToken, (req, res) => {\r\n  const appointmentId = req.params.id;\r\n  const userId = req.user.userId;\r\n\r\n  // Verify appointment belongs to user\r\n  db.get(\"SELECT * FROM appointments WHERE id = ? AND user_id = ?\", [appointmentId, userId], (err, appointment) => {\r\n    if (err) return res.status(500).json({ error: err.message });\r\n    if (!appointment) return res.status(404).json({ error: 'Appointment not found or unauthorized' });\r\n\r\n    // Update appointment status\r\n    db.run(\"UPDATE appointments SET status = 'cancelled' WHERE id = ?\", [appointmentId], function(err) {\r\n      if (err) return res.status(500).json({ error: err.message });\r\n      res.json({ message: 'Appointment cancelled successfully' });\r\n    });\r\n  });\r\n});\r\n\r\n// Logout (client-side token removal, but useful for logging)\r\napp.post('/api/logout', authenticateToken, (req, res) => {\r\n  // In a production app, you might want to blacklist the token\r\n  res.json({ message: 'Logout successful' });\r\n});\r\n\r\n// ------------------------ Start Server ------------------------ //\r\n\r\napp.listen(PORT, () => {\r\n  console.log(`✅ Server running at http://localhost:${PORT}`);\r\n  console.log(`🔐 JWT Authentication enabled`);\r\n});\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGINT', () => {\r\n  db.close(() => {\r\n    console.log('\\nDatabase closed. Server shutting down.');\r\n    process.exit(0);\r\n  });\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}